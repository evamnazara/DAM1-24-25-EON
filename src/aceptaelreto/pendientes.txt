

ENCRIPTACION MENSAJES

Encriptación de mensajes
Tiempo máximo: 1,000 s Memoria máxima: 4096 KiB
Uno de los métodos más antiguos para codificar mensajes es el conocido como cifrado Cesar. Su funcionamiento es simple: cada una de las letras del mensaje original es sustituida por otra letra que se encuentra un número fijo de posiciones más adelante en el alfabeto.

Así, si utilizamos un desplazamiento de 2, las apariciones de la letra 'a' se sustituyen por la 'c', todas las apariciones de la 'b' por 'd', etc. El método tradicional comienza de nuevo al llegar al final del alfabeto, de forma que, con el desplazamiento de 2, la 'y' se sustituye por la 'a' y la 'z' se sustituye por la 'b'.

Los desplazamientos también pueden ser negativos; si utilizamos un desplazamiento de -1, la 'E' se convertirá en 'D', mientras que la 'a' pasará a ser 'z'.

Nuestro cifrado Cesar no codifica los caracteres que no sean letras anglosajonas. Así, por ejemplo, los espacios o los símbolos de puntuación no sufrirán cambio alguno.

Entrada

La entrada está formada por un número indeterminado de casos de prueba.

Cada caso de prueba consiste en una única línea cuyo primer carácter es el código de la letra 'p', seguido de un mensaje codificado con el método Cesar descrito antes utilizando el desplazamiento adecuado para que la letra 'p' se codifique con ese primer carácter.

Los casos de prueba terminan con un mensaje codificado que, una vez traducido, contiene exactamente la cadena "FIN". Cuando se lee este mensaje codificado el programa debe terminar sin generar ninguna otra salida más.

Salida

Para cada caso de prueba, el programa indicará el número de vocales no acentuadas que contiene el mensaje codificado.

Entrada de ejemplo

pEsta cadena esta sin codificar
pfin
qbfjpvBFJPV
ozdhntZDHNT
xXzwoziui-Um
qGJO


import java.util.Scanner;

public class CifradoCesar {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            // Leer la línea completa
            String linea = scanner.nextLine();

            // El primer carácter indica cómo se ha cifrado la letra 'p'
            char letraCodificada = linea.charAt(0);
            String mensajeCifrado = linea.substring(1); // El resto es el mensaje cifrado

            // Calcular el desplazamiento usado en el cifrado
            int desplazamiento = calcularDesplazamiento(letraCodificada, 'p');

            // Decodificar el mensaje
            String mensajeOriginal = decodificarMensaje(mensajeCifrado, desplazamiento);

            // Si el mensaje original es "FIN", terminamos el programa
            if (mensajeOriginal.equals("FIN")) {
                break;
            }

            // Contar el número de vocales en el mensaje cifrado
            int cantidadVocales = contarVocales(mensajeCifrado);

            // Imprimir el número de vocales
            System.out.println(cantidadVocales);
        }

        scanner.close();
    }

    // Calcula el desplazamiento que se ha utilizado para cifrar
    public static int calcularDesplazamiento(char letraCodificada, char letraOriginal) {
        int codigoCodificado = letraCodificada;
        int codigoOriginal = letraOriginal;
        int desplazamiento = codigoCodificado - codigoOriginal;

        return desplazamiento;
    }

    // Decodifica el mensaje aplicando el cifrado César en sentido inverso
    public static String decodificarMensaje(String mensaje, int desplazamiento) {
        String resultado = "";

        for (int i = 0; i < mensaje.length(); i++) {
            char caracter = mensaje.charAt(i);
            char caracterDecodificado = descifrarCaracter(caracter, desplazamiento);
            resultado += caracterDecodificado; // Concatenación en lugar de StringBuilder
        }

        return resultado;
    }

    // Desplaza un carácter en sentido inverso según el desplazamiento dado
    public static char descifrarCaracter(char caracter, int desplazamiento) {
        if (esLetra(caracter)) {
            int base = (esMayuscula(caracter)) ? 'A' : 'a';
            int posicionOriginal = (caracter - base - desplazamiento + 26) % 26;
            return (char) (base + posicionOriginal);
        }
        return caracter; // No cambia si no es una letra
    }

    // Verifica si un carácter es una letra del alfabeto inglés
    public static boolean esLetra(char c) {
        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
    }

    // Verifica si un carácter es una letra mayúscula
    public static boolean esMayuscula(char c) {
        return (c >= 'A' && c <= 'Z');
    }

    // Cuenta las vocales en un mensaje
    public static int contarVocales(String mensaje) {
        int contador = 0;
        for (int i = 0; i < mensaje.length(); i++) {
            char c = mensaje.charAt(i);
            if (esVocal(c)) {
                contador++;
            }
        }
        return contador;
    }

    // Verifica si un carácter es una vocal (sin acentos)
    public static boolean esVocal(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
}

===============

LA FIESTA ABURRIDA 


La fiesta aburrida
Tiempo máximo: 1,000 s Memoria máxima: 2048 KiB
Tinín es un tipo bastante peculiar. No le gustan nada las fiestas, ni las celebraciones, ni las cenas familiares o con amigos. Nada. Es sorprendente que, a pesar de sus pocas ganas de interactuar con gente, haya encontrado novia.

Cuando ésta consigue sacarle de casa para llevarle a algún tipo de celebración y la gente le dice "Hombre, Tinín, ¡pero si has venido!" él siempre suelta su mítica frase "Yo soy más traído que venido.".

Una de las cosas que más le molesta es tener que ir saludando a todos los presentes, sobre todo si no le conocen. Eso de que se le acerquen y le digan "Soy Lotario" y que él tenga que saludar no lo soporta. ¿Puedes ayudarle?

Entrada

La entrada comienza con un número que indica la cantidad de gente a la que Tinín no conoce en la fiesta en la que está. A continuación viene una línea por cada una de esas personas en la que se presenta indicando su nombre: "Soy Lotario". La línea siempre tendrá el mismo formato; una primera palabra "Soy" seguida del nombre de la persona que será simple (no será un nombre compuesto por varias palabras) y formado por como mucho 100 letras del alfabeto inglés.

Salida

Para cada persona que se le aproxima, se debe escribir la cadena "Hola, [nombre].".

Entrada de ejemplo

3
Soy Lotario
Soy Aldonza
Soy Ender
Salida de ejemplo

Hola, Lotario.
Hola, Aldonza.
Hola, Ender.
=======

import java.util.Scanner;

public class FiestaAburrida {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Leer el número de personas que Tinín no conoce
        String primeraLinea = scanner.nextLine();
        int cantidadPersonas = convertirAEntero(primeraLinea); 

        // Procesar cada presentación
        for (int i = 0; i < cantidadPersonas; i++) {
            String linea = scanner.nextLine();  // Leer la línea con "Soy [nombre]"
            String nombre = extraerNombre(linea);  // Extraer el nombre de la persona
            System.out.println("Hola, " + nombre + ".");  // Imprimir saludo
        }

        scanner.close();
    }

    // Función para convertir un número en String a entero sin usar parseInt()
    public static int convertirAEntero(String numero) {
        int resultado = 0;
        for (int i = 0; i < numero.length(); i++) {
            char digito = numero.charAt(i);
            resultado = resultado * 10 + (digito - '0');
        }
        return resultado;
    }

    // Función para extraer el nombre de la frase "Soy [nombre]"
    public static String extraerNombre(String frase) {
        return frase.substring(4);  // "Soy " tiene 4 caracteres, extraemos desde ahí
    }
}

=====

CADENAS ADN 

Comparando cadenas de ADN
Tiempo máximo: 3,000-4,000 s Memoria máxima: 196608 KiB
El ADN (o en su nombre largo el ácido desoxirribonucleico) es apasionante. Es una molécula clave para los seres vivos que contiene la información para construir otros componentes celulares. Además es la responsable de la transmisión hereditaria y de que los hijos se parezcan a sus padres.

Gracias a esa transmisión hereditaria, el análisis del ADN ha servido a los científicos para desentrañar muchos misterios. Por ejemplo, gracias a algunos proyectos científicos se han podido rastrear migraciones humanas de hace miles de años en base a las similitudes y diferencias entre el ADN encontrado en distintos yacimientos. Sin irnos tan lejos, 135 años después de que tuvieran lugar los crímenes del famoso Jack el Destripador a finales del siglo XIX, varios científicos aseguraron tener pruebas de ADN que podrían demostrar su identidad. Las pruebas se basaban en la comparación entre una muestra de ADN recogida de ropa conservada del asesino y el ADN de un descendiente de uno de los sospechosos que barajó en su momento Scotland Yard.

El hecho de que el ADN de una persona sea único (exceptuando hermanos gemelos) hace que sirva también a la policía forense para esclarecer crímenes mucho más cercanos. Si se compara ADN encontrado en el lugar del crimen con el ADN de un sospechoso y resultan ser iguales, el sospechoso tendrá que dar muchas más explicaciones para salirse sin una sentencia en contra.

No obstante, determinar si dos muestras de ADN son de la misma persona no es tarea fácil pues las muestras que se recogen no están siempre completas. Para entenderlo mejor diremos que una cadena de ADN está compuesta por cuatro tipos de nucleótidos: Adenina, Citosina, Guanina y Timina (A, C, G y T). En un mundo ideal, si nos dan dos cadenas de ADN con la lista ordenada de nucleótidos que tiene cada una, basta comparar si los caracteres coinciden. En la práctica no es tan fácil pues muchas veces algunos de los nucleótidos se han perdido (principalmente en las esquinas).

Dada una serie de cadenas de ADN, para cada una de ellas ¿cuántas de las otras podrían pertenecer al mismo individuo?

Entrada

La entrada estará formada por distintos casos de prueba. Cada uno comienza con una línea que indica el número de cadenas de ADN que se darán (hasta 40.000). A continuación vendrá una línea con cada una de las cadenas, todas con la misma longitud (como mucho 50 caracteres).

Cada cadena de ADN tendrá los caracteres A, C, G y T indicando el nucleótido colocado en esa posición o un guión (-) indicando un hueco (nucleótido desconocido) en la cadena. De haber huecos o guiónes estos estarán colocados principalmente en los laterales de la cadena; en la parte central nunca habrá más de 2.

Dos cadenas pueden pertenecer al mismo individuo si en las posiciones en las que ambas tienen nucleótido conocido, este coincide.

Salida

Por cada caso de prueba se escribirá una línea con tantos números como cadenas de ADN se han dado. El número en la posición i indicará cuántas cadenas iguales a la cadena colocada en la posición i hay (sin contar a ella misma), teniendo en cuenta que los guiones se consideran igual a cualquier otro nucleótido (o a otro guión)

Entrada de ejemplo

3
--AAA-
------
-TTT--
4
AAA
-AA
AA-
---
1
ACGT

=========

import java.util.Scanner;

public class ComparadorADN {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNextLine()) {
            // Leer el número de cadenas de ADN
            String primeraLinea = scanner.nextLine();
            int cantidadCadenas = convertirAEntero(primeraLinea);

            if (cantidadCadenas == 0) {
                break; // Caso base para terminar
            }

            // Leer las cadenas de ADN
            String[] cadenasADN = new String[cantidadCadenas];
            for (int i = 0; i < cantidadCadenas; i++) {
                cadenasADN[i] = scanner.nextLine();
            }

            // Array para contar coincidencias
            int[] conteo = new int[cantidadCadenas];

            // Comparar cada cadena con las demás
            for (int i = 0; i < cantidadCadenas; i++) {
                for (int j = i + 1; j < cantidadCadenas; j++) {
                    if (esPosibleCoincidencia(cadenasADN[i], cadenasADN[j])) {
                        conteo[i]++;
                        conteo[j]++;
                    }
                }
            }

            // Imprimir el resultado
            for (int i = 0; i < cantidadCadenas; i++) {
                if (i > 0) {
                    System.out.print(" ");
                }
                System.out.print(conteo[i]);
            }
            System.out.println(); // Nueva línea al final de cada caso
        }

        scanner.close();
    }

    // Convierte un String numérico a entero sin usar parseInt()
    public static int convertirAEntero(String numero) {
        int resultado = 0;
        for (int i = 0; i < numero.length(); i++) {
            char digito = numero.charAt(i);
            resultado = resultado * 10 + (digito - '0');
        }
        return resultado;
    }

    // Verifica si dos cadenas de ADN pueden pertenecer al mismo individuo
    public static boolean esPosibleCoincidencia(String adn1, String adn2) {
        int longitud = adn1.length();

        for (int i = 0; i < longitud; i++) {
            char nucleotido1 = adn1.charAt(i);
            char nucleotido2 = adn2.charAt(i);

            // Si ambos tienen nucleótido definido y son distintos, no son compatibles
            if (nucleotido1 != '-' && nucleotido2 != '-' && nucleotido1 != nucleotido2) {
                return false;
            }
        }
        return true;
    }
}


=======

QUINTO MILENIO 

Quinto milenio
Tiempo máximo: 1,000-5,000 s Memoria máxima: 4096 KiB
Túker Chiménez ve cosas escondidas en cualquier lado. Una mancha de humedad en la pared se le antoja la cara de la anterior propietaria de una casa; el sonido del viento le parece un susurro venido del más allá; una nube con forma peculiar le convence de la existencia de vida extraterrestre.

Ahora le ha dado por ver mensajes ocultos en cualquier sitio. Por poner un ejemplo, si lee el siguiente titular: "El presidente del Gobierno se somete esta noche al escrutinio de varios periodistas en Televisión Española.", se las ingenia para leer un "te odio" oculto que le mantiene en vela toda la noche:

El presidenTe dEl Gobierno se sOmete esta noche al escrutinio De varIos periOdistas en Televisión Española.

Ahora quiere automatizar la tarea de la búsqueda de estos mensajes.

Entrada

La entrada comenzará con un entero que indica el número de casos de prueba. Cada uno de ellos está formado por dos líneas; la primera indica el titular donde buscar un mensaje oculto y la segunda indica el mensaje a buscar. La longitud de cada una de las cadenas no excederá los 2000 caracteres. Ten en cuenta que no hace falta distinguir entre mayúsculas y minúsculas y que los espacios del mensaje oculto no son relevantes, es decir, no hace falta que existan en el mensaje original, pero sí deben aparecer el resto de caracteres (signos de puntuación, comillas, etc.). Se garantiza que el mensaje oculto a buscar no empieza ni termina por espacios.

La entrada contendrá únicamente letras del alfabeto inglés, por lo que no aparecerán vocales con tilde. Además, podrían aparecer múltiples espacios consecutivos.

Salida

Para cada caso de prueba el programa escribirá SI si el mensaje buscado aparece en el titular y NO en caso contrario.

Entrada de ejemplo

4
...dente ...somete ... de varios periodistas ...
te odio.
Teo dijo "si".
te odio.
Y adios, que ya viene el alba.
te odio.
Teo    subio  al    podio.
te          odio.

====
import java.util.Scanner;

public class QuintoMilenio {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Leer el número de casos de prueba
        String primeraLinea = scanner.nextLine();
        int numeroCasos = convertirAEntero(primeraLinea);

        // Procesar cada caso de prueba
        for (int i = 0; i < numeroCasos; i++) {
            String titular = scanner.nextLine();
            String mensaje = scanner.nextLine();

            // Convertir a minúsculas
            titular = convertirAMinusculas(titular);
            mensaje = convertirAMinusculas(mensaje);

            // Eliminar espacios del mensaje oculto
            String mensajeSinEspacios = eliminarEspacios(mensaje);

            // Verificar si el mensaje oculto aparece en el titular en orden
            boolean encontrado = buscarMensajeOculto(titular, mensajeSinEspacios);

            // Imprimir el resultado
            if (encontrado) {
                System.out.println("SI");
            } else {
                System.out.println("NO");
            }
        }

        scanner.close();
    }

    // Convierte un String numérico a entero sin usar parseInt()
    public static int convertirAEntero(String numero) {
        int resultado = 0;
        for (int i = 0; i < numero.length(); i++) {
            char digito = numero.charAt(i);
            resultado = resultado * 10 + (digito - '0');
        }
        return resultado;
    }

    // Convierte una cadena a minúsculas sin usar toLowerCase()
    public static String convertirAMinusculas(String texto) {
        char[] caracteres = texto.toCharArray();
        for (int i = 0; i < caracteres.length; i++) {
            if (caracteres[i] >= 'A' && caracteres[i] <= 'Z') {
                caracteres[i] = (char) (caracteres[i] + 32); // Convertir a minúscula
            }
        }
        return new String(caracteres);
    }

    // Elimina espacios de una cadena sin usar replace()
    public static String eliminarEspacios(String texto) {
        char[] caracteres = texto.toCharArray();
        String resultado = "";
        for (char c : caracteres) {
            if (c != ' ') {
                resultado += c;
            }
        }
        return resultado;
    }

    // Verifica si el mensaje oculto aparece en orden dentro del titular
    public static boolean buscarMensajeOculto(String titular, String mensaje) {
        int indiceMensaje = 0;
        int longitudMensaje = mensaje.length();

        // Recorrer el titular buscando el mensaje en orden
        for (int i = 0; i < titular.length(); i++) {
            if (titular.charAt(i) == mensaje.charAt(indiceMensaje)) {
                indiceMensaje++;
                if (indiceMensaje == longitudMensaje) {
                    return true; // Se encontró todo el mensaje en orden
                }
            }
        }
        return false; // No se encontró el mensaje
    }
}

=======

CODIGO MORSE

Aprendiendo el código Morse
Tiempo máximo: 1,000 s Memoria máxima: 4096 KiB
Todos hemos oído hablar del código o alfabeto Morse, que antiguamente servía para transmitir mensajes de telégrafo. El código consiste en la codificación de cada letra del abecedario con una sucesión de puntos y rayas que se traducen a señales auditivas cortas (puntos) o largas (rayas), siguiendo las transformaciones que se indican en la tabla.

Letra	Código		Letra	Código
A	.-		N	-.
B	-...		O	---
C	-.-.		P	.--.
D	-..		Q	--.-
E	.		R	.-.
F	..-.		S	...
G	--.		T	-
H	....		U	..-
I	..		V	...-
J	.---		W	.--
K	-.-		X	-..-
L	.-..		Y	-.--
M	--		Z	--..
El código, no obstante, es bastante complicado de aprender y utilizar. Por una parte hay que aprenderse los códigos de cada letra. Por otra, hay que añadir pausas entre cada símbolo, al existir codificaciones de letras que son prefijos de otras, y pausas más largas entre cada palabra, pues el "espacio" no tiene ningún código asociado.

Una guía de ayuda para aprenderse la tabla de codificación consiste en tener una palabra de referencia para cada letra. Así, por ejemplo, para la letra 'A' podemos memorizar Arco. La palabra elegida para cada letra debe comenzar por esa letra y ser tal que si cada vocal 'o' se sustituye por una raya, y el resto de vocales por un punto, el resultado final sea la codificación de la letra en cuestión.

A continuación aparecen algunos ejemplos de palabras que pueden utilizarse como palabras de referencia:

Letra	Palabra de referencia	Código
A	Arco	.-
B	Bogavante	-...
C	Corazones	-.-.
Ahora estamos haciendo una tabla nueva y tenemos que comprobar si, dada una palabra, podemos o no utilizarla como palabra de referencia.
Entrada

La entrada consiste en una serie de palabras de no más de 20 letras, cada una en una línea independiente. Cada palabra contendrá únicamente símbolos del alfabeto inglés ya sea en mayúscula o en minúscula. Las palabras no contendrán tildes (aunque eso implique no escribir correctamente la palabra).

Salida

Para cada palabra se mostrará en una línea independiente si puede ser utilizada como palabra de referencia según la descripción dada. En caso afirmativo se escribirá la palabra leída seguida de "OK". En caso negativo, tras la palabra se escribira "X".

Entrada de ejemplo

Arco
Corazones
ARBOLES
Salida de ejemplo

Arco OK
Corazones OK
ARBOLES X


=====
import java.util.Scanner;

public class CodigoMorse {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Tabla de código Morse según la primera letra
        String[] morseAlfabeto = {
            ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---",
            "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-",
            "..-", "...-", ".--", "-..-", "-.--", "--.."
        };

        while (scanner.hasNextLine()) {
            String palabra = scanner.nextLine();
            if (palabra.isEmpty()) {
                break;
            }

            // Convertimos la palabra a código Morse siguiendo las reglas
            String codigoGenerado = generarCodigoMorse(palabra);

            // Identificar el índice de la primera letra en el alfabeto (A-Z)
            char primeraLetra = Character.toUpperCase(palabra.charAt(0));
            int indice = primeraLetra - 'A';
            String codigoEsperado = morseAlfabeto[indice];

            // Comparar el código generado con el esperado
            if (codigoGenerado.equals(codigoEsperado)) {
                System.out.println(palabra + " OK");
            } else {
                System.out.println(palabra + " X");
            }
        }

        scanner.close();
    }

    // Genera el código Morse según la palabra dada
    public static String generarCodigoMorse(String palabra) {
        String resultado = "";

        for (int i = 0; i < palabra.length(); i++) {
            char letra = Character.toLowerCase(palabra.charAt(i));
            if (letra == 'o') {
                resultado += "-";  // 'o' se convierte en raya
            } else if (letra == 'a' || letra == 'e' || letra == 'i' || letra == 'u') {
                resultado += ".";  // Otras vocales se convierten en punto
            }
        }

        return resultado;
    }
}

====

ANELIDOS 


Como si fueras un programador de java novato, resuelve el siguiente problema. Utiliza variables claras, explica cada paso que haces. Puedes utilizar funciones básicas de Strings, pero no utilices funciones de parseo ni StringBuilder.

Anélidos
Tiempo máximo: 2,000 s Memoria máxima: 8192 KiB
Los anélidos son una variedad de lo que coloquialmente se conoce como gusanos. Su propiedad más característica (y que los diferencia del resto de variedades) es que sus cuerpos están compuestos por la repetición de "anillos" con la misma estructura, repitiéndose en cada anillo todos los órganos internos y externos. Seguramente los anélidos más conocidos sean las orugas.
En algunos lugares de la selva tropical se da una variedad de oruga, llamada thuelis, que intriga desde hace muchos años a los biólogos. Cuando nacen, poseen únicamente un anillo (además de la cabeza), de color o bien amarillo, o bien negro. En cada fase de crecimiento todos sus anillos se replican, de forma que donde antes había un anillo ahora aparecen dos. En particular cada anillo da lugar, a su lado y más cerca que él de la cabeza, a un nuevo anillo del color contrario:
Estas orugas crecen indefinidamente siguiendo ese patrón. Aunque no son venenosas, los colores que muestran son similares a los de otras especies que sí lo son, por lo que los depredadores suelen evitarlas. Se han llegado a encontrar ejemplares de casi dos metros.
Para una distribución inicial de anillos, ¿eres capaz de decir qué colores tendrán después de varias fases de crecimiento?
Entrada
La entrada estará compuesta de varios casos de prueba. Cada uno empezará con un número entero no negativo que indicará cuantas fases de crecimiento hay que simular. Después vendrá una cadena indicando los colores de los anillos del ejemplar (A para amarillo y N para negro), acabando con la letra C que indica la posición de la cabeza.
Ten en cuenta que, en muy raras ocasiones, el crecimiento no sigue el patrón habitual, por lo que las configuraciones iniciales de la entrada nonecesariamente serán alcanzables desde alguno de las dos variedades de nacimiento de los thuelis (un único anillo amarillo o negro).
La entrada terminará cuando se reciba un thuelis sin anillos.
Salida
Para cada caso de prueba el programa deberá indicar, en una línea, la configuración de colores de los anillos tras el número solicitado de fases de crecimiento, asumiendo que todas siguen el patrón habitual descrito. Se usará, como en la entrada, Apara amarillo y N para negro, acabando con la C para la cabeza. No se añadirán espacios en ningún caso.
====

import java.util.Scanner;

public class Anelidos {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNextLine()) {
            // Leer la línea de entrada
            String linea = scanner.nextLine().trim();
            
            // Separar número de fases y cadena inicial de anillos
            int espacio = encontrarEspacio(linea);
            if (espacio == -1) {
                break; // No hay un número de fases, fin de entrada
            }

            // Obtener número de fases sin usar parseo
            int fases = convertirAEntero(linea.substring(0, espacio));
            String anillos = linea.substring(espacio + 1); // Cadena de anillos con 'C' al final

            // Si la cadena de anillos es solo "C", terminar
            if (anillos.equals("C")) {
                break;
            }

            // Simular el crecimiento
            for (int i = 0; i < fases; i++) {
                anillos = crecerAnelido(anillos);
            }

            // Imprimir el resultado
            System.out.println(anillos);
        }

        scanner.close();
    }

    // Encuentra el primer espacio en la línea de entrada
    public static int encontrarEspacio(String texto) {
        for (int i = 0; i < texto.length(); i++) {
            if (texto.charAt(i) == ' ') {
                return i;
            }
        }
        return -1; // No se encontró espacio
    }

    // Convierte un número en formato String a entero sin usar parseInt()
    public static int convertirAEntero(String numero) {
        int resultado = 0;
        for (int i = 0; i < numero.length(); i++) {
            char digito = numero.charAt(i);
            resultado = resultado * 10 + (digito - '0'); // Convertir char a número
        }
        return resultado;
    }

    // Simula una fase de crecimiento del anélido
    public static String crecerAnelido(String anillos) {
        String nuevaCadena = "";

        // Iterar sobre la cadena original sin incluir la 'C' final
        for (int i = 0; i < anillos.length() - 1; i++) {
            char anillo = anillos.charAt(i);
            if (anillo == 'A') {
                nuevaCadena += "NA"; // 'A' se convierte en "NA"
            } else if (anillo == 'N') {
                nuevaCadena += "AN"; // 'N' se convierte en "AN"
            }
        }

        return nuevaCadena + "C"; // Añadir la cabeza al final
    }
}


=====


MATRICES

e

EL HOMBRE SIN MIEDO Y SIN RADAR

El hombre sin miedo y sin radar
Tiempo máximo: 2,000 s Memoria máxima: 4096 KiB
Daredevil, también conocido como "El hombre sin miedo", es un superhéroe que quedó ciego de niño por culpa de una sustancia radiactiva. Dicha sustancia le hizo perder la vista pero, al mismo tiempo, agudizó el resto de sus sentidos.

Así, Daredevil desarrolló un sistema de radar (similar a la ecolocalización) que le permite saber en qué lugar están los villanos con los que va a combatir.

Sin embargo, su archienemigo Kingpin le ha tendido una trampa y le ha encerrado en una habitación cuya resonancia anula su sistema de radar. Además, ha convocado a un montón de villanos que le esperan con rencor para darle una paliza.

Daredevil todavía no sabe la que se le viene encima pero, afortunadamente, tiene un gadget programable que quizá pueda ayudarle.

Entrada

El programa deberá procesar múltiples casos de prueba. Cada uno comienza con la descripción de la sala a la que llega Daredevil. Una sala es un espacio rectangular organizado en celdas, cada una de las cuales puede estar libre u ocupada por un villano.

La primera línea del caso de prueba contiene dos números, 1 ≤ F, C ≤ 100 indicando la cantidad de filas y columnas que tiene la sala. A continuación vienen F líneas de C letras cada una. Las letras pueden ser "X" para indicar que la celda está ocupada por un villano, o "." para indicar que está vacía.

Tras el mapa del caso de prueba aparece un número 1 ≤ N ≤ 100 con la cantidad de consultas que se realizarán sobre ese mapa. Cada consulta es una posición donde podría estar Daredevil y la dirección hacia la que apunta con su gadget. La posición se indica proporcionando primero el número de fila, y luego el número de columna. La celda (1,1) se encuentra en la esquina superior izquierda del mapa. La dirección será IZQUIERDA, DERECHA, ARRIBA o ABAJO. Se garantiza que no se realizará ninguna consulta en una posición ocupada por un villano.

La entrada termina con dos ceros.

Salida

Por cada consulta se escribirá, en una línea independiente, la distancia, en número de celdas, al villano más cercano desde la posición de la consulta en la dirección indicada. Si no hay ningún villano, se escribirá "NINGUNO".

Al final de cada caso de prueba se escribirá "---".

Entrada de ejemplo

3 8
.X....X.
...X....
....X...
3
3 2 ARRIBA
2 1 DERECHA
1 1 ABAJO
0 0
========
Aquí tienes una solución en Java explicada paso a paso, utilizando solo estructuras básicas y sin List, parseInt() ni funciones avanzadas.

Estrategia para resolver el problema
	1.	Leer la entrada
	•	Se leen dos números F y C que indican el tamaño de la sala.
	•	Luego se leen F líneas con C caracteres (X para villano, . para espacio libre).
	•	Se almacena el mapa en un arreglo bidimensional (char[][]).
	2.	Leer las consultas
	•	Se lee N, el número de consultas.
	•	Para cada consulta:
	•	Se obtiene la fila y la columna donde está Daredevil.
	•	Se lee la dirección (ARRIBA, ABAJO, IZQUIERDA, DERECHA).
	3.	Buscar el villano más cercano en la dirección dada
	•	Se empieza desde la posición de Daredevil y se avanza en la dirección indicada.
	•	Se cuenta cuántas celdas se recorren hasta encontrar un X o salir del mapa.
	•	Si se encuentra un X, se imprime la distancia.
	•	Si no se encuentra ninguno, se imprime "NINGUNO".
	4.	Imprimir los resultados
	•	Para cada consulta se imprime la distancia al villano o "NINGUNO".
	•	Al final de cada caso de prueba, se imprime "---".

Código en Java

import java.util.Scanner;

public class DaredevilSinRadar {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            // Leer filas y columnas
            int filas = scanner.nextInt();
            int columnas = scanner.nextInt();
            
            // Caso de terminación (0 0)
            if (filas == 0 && columnas == 0) {
                break;
            }

            // Leer la sala en un arreglo bidimensional
            char[][] sala = new char[filas][columnas];
            for (int i = 0; i < filas; i++) {
                String linea = scanner.next();
                for (int j = 0; j < columnas; j++) {
                    sala[i][j] = linea.charAt(j);
                }
            }

            // Leer número de consultas
            int numConsultas = scanner.nextInt();
            
            // Procesar cada consulta
            for (int i = 0; i < numConsultas; i++) {
                int fila = scanner.nextInt() - 1; // Convertir a índice base 0
                int columna = scanner.nextInt() - 1;
                String direccion = scanner.next();

                // Determinar la distancia al villano más cercano
                int distancia = buscarVillano(sala, filas, columnas, fila, columna, direccion);
                
                // Imprimir resultado
                if (distancia == -1) {
                    System.out.println("NINGUNO");
                } else {
                    System.out.println(distancia);
                }
            }

            // Separador entre casos
            System.out.println("---");
        }

        scanner.close();
    }

    // Busca la distancia al villano más cercano en la dirección dada
    public static int buscarVillano(char[][] sala, int filas, int columnas, int fila, int columna, String direccion) {
        int distancia = 0;

        // Determinar cómo moverse en función de la dirección
        int incrementoFila = 0;
        int incrementoColumna = 0;

        if (direccion.equals("ARRIBA")) {
            incrementoFila = -1;
        } else if (direccion.equals("ABAJO")) {
            incrementoFila = 1;
        } else if (direccion.equals("IZQUIERDA")) {
            incrementoColumna = -1;
        } else if (direccion.equals("DERECHA")) {
            incrementoColumna = 1;
        }

        // Moverse en la dirección hasta encontrar un villano o salir del mapa
        while (true) {
            fila += incrementoFila;
            columna += incrementoColumna;
            distancia++;

            // Verificar si se salió del mapa
            if (fila < 0 || fila >= filas || columna < 0 || columna >= columnas) {
                return -1; // No hay villano en esta dirección
            }

            // Si encontramos un villano, devolver la distancia
            if (sala[fila][columna] == 'X') {
                return distancia;
            }
        }
    }
}

Explicación del código

1. Leer la entrada
	•	scanner.nextInt() obtiene filas y columnas.
	•	Si ambos son 0, se termina el programa.
	•	Se usa un char[][] para almacenar la sala.
	•	Se lee cada línea del mapa y se guarda en el arreglo.

2. Leer las consultas
	•	scanner.nextInt() obtiene numConsultas.
	•	Para cada consulta:
	•	Se obtienen la fila y la columna (restando 1 para convertir a índice base 0).
	•	Se lee la dirección (ARRIBA, ABAJO, IZQUIERDA, DERECHA).

3. Buscar el villano más cercano
	•	Se usa una función buscarVillano(), que:
	•	Usa un while para moverse en la dirección indicada.
	•	Si se sale del mapa, devuelve -1 (“NINGUNO”).
	•	Si encuentra X, devuelve la distancia


=======
EL CUELLO DE LOS PILOTOS

El cuello de los pilotos
Tiempo máximo: 1,000 s Memoria máxima: 4096 KiB
Cualquiera con dos dedos de frente entiende que los ciclistas deben cuidar sobre todo sus rodillas y los tenistas el codo. Lo que es menos conocido es la importancia del cuello en los pilotos de Fórmula 1.

La necesidad de un cuello en forma en estos conductores se debe a las fuertes aceleraciones y deceleraciones que sufren durante las carreras, especialmente en las curvas.

Por eso cuando se incorpora un nuevo circuito en el calendario del mundial sus curvas se analizan minuciosamente. Aunque en un estudio real se miden muchos más factores, nosotros nos conformaremos con contar el número de curvas a la izquierda y a la derecha que tienen esos nuevos circuitos.

Entrada

La entrada está compuesta por distintos casos de prueba, cada uno representando el mapa de un circuito cuyas curvas hay que contar.

La descripión de cada mapa comienza con una línea con dos números tx y ty que indican su ancho y alto (un mínimo de 3 y un máximo de 100 unidades por cada dimensión).

A continuación aparecen ty líneas, con tx caracteres cada una. Cada carácter puede ser un punto (".") que indica campo y una almohadilla ("#") que indica una sección del circuito. Dentro de éste, el carácter "O" (o mayúscula) marca la posición desde la que comienza la carrera, que nunca estará situada en una curva.

En nuestros circuitos los coches siempre van en horizontal o vertical (nunca en diagonal) y recorren el circuito en sentido de las agujas del reloj.

Salida

Por cada caso de prueba se escribirá una única línea con dos números separados por un espacio. El primero indica las curvas hacia la izquierda y el segundo las curvas hacia la derecha que deben hacer los pilotos en el circuito.

Entrada de ejemplo

3 3
#O#
#.#
###
15 5
..#####..###...
..#...####.##..
###.........#..
O.....####..#..
#######..####..

================

Aquí tienes una solución en Java explicada paso a paso, utilizando solo estructuras básicas y sin funciones avanzadas ni List.

Estrategia para resolver el problema
	1.	Leer la entrada
	•	Se leen dos números tx y ty que indican el tamaño del mapa del circuito.
	•	Luego se leen ty líneas con tx caracteres (# para el circuito, . para campo, O para la posición inicial).
	2.	Encontrar el punto de inicio (O)
	•	Se busca en la matriz de caracteres la posición donde se encuentra O.
	3.	Seguir el circuito en sentido horario
	•	Como los coches siempre se mueven en líneas rectas (horizontal o vertical), debemos seguir el camino de # hasta recorrer todo el circuito.
	•	Cada vez que cambia la dirección, verificamos si la curva es hacia la izquierda o hacia la derecha.
	4.	Contar las curvas
	•	Se lleva un registro de la dirección actual (arriba, abajo, izquierda, derecha).
	•	Cada vez que la dirección cambia, se determina si el giro es a la izquierda o derecha y se incrementa el contador correspondiente.
	5.	Imprimir el resultado
	•	Se imprime el número de curvas a la izquierda y a la derecha.

Código en Java

import java.util.Scanner;

public class CuelloPilotos {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNextInt()) {
            // Leer dimensiones del circuito
            int ancho = scanner.nextInt();
            int alto = scanner.nextInt();
            scanner.nextLine(); // Consumir el salto de línea
            
            // Leer el mapa del circuito
            char[][] circuito = new char[alto][ancho];
            int inicioFila = -1, inicioColumna = -1;

            for (int i = 0; i < alto; i++) {
                String linea = scanner.nextLine();
                for (int j = 0; j < ancho; j++) {
                    circuito[i][j] = linea.charAt(j);
                    if (circuito[i][j] == 'O') {
                        inicioFila = i;
                        inicioColumna = j;
                    }
                }
            }

            // Direcciones de movimiento: {derecha, abajo, izquierda, arriba}
            int[] movFila = {0, 1, 0, -1};
            int[] movColumna = {1, 0, -1, 0};
            String[] direcciones = {"DERECHA", "ABAJO", "IZQUIERDA", "ARRIBA"};

            // Encontrar la dirección inicial (buscando un '#')
            int dirActual = -1;
            for (int d = 0; d < 4; d++) {
                int nuevaFila = inicioFila + movFila[d];
                int nuevaColumna = inicioColumna + movColumna[d];

                if (nuevaFila >= 0 && nuevaFila < alto && nuevaColumna >= 0 && nuevaColumna < ancho
                        && circuito[nuevaFila][nuevaColumna] == '#') {
                    dirActual = d;
                    break;
                }
            }

            // Recorrer el circuito
            int curvasIzquierda = 0;
            int curvasDerecha = 0;
            int fila = inicioFila, columna = inicioColumna;

            do {
                // Intentar seguir recto
                int nuevaFila = fila + movFila[dirActual];
                int nuevaColumna = columna + movColumna[dirActual];

                if (nuevaFila >= 0 && nuevaFila < alto && nuevaColumna >= 0 && nuevaColumna < ancho
                        && circuito[nuevaFila][nuevaColumna] == '#') {
                    fila = nuevaFila;
                    columna = nuevaColumna;
                    continue;
                }

                // Si no se puede seguir recto, buscar nueva dirección
                int nuevaDir = -1;
                for (int i = 1; i <= 3; i++) { // Girar en sentido horario
                    int d = (dirActual + i) % 4;
                    nuevaFila = fila + movFila[d];
                    nuevaColumna = columna + movColumna[d];

                    if (nuevaFila >= 0 && nuevaFila < alto && nuevaColumna >= 0 && nuevaColumna < ancho
                            && circuito[nuevaFila][nuevaColumna] == '#') {
                        nuevaDir = d;
                        break;
                    }
                }

                // Contar curva
                if (nuevaDir != -1) {
                    if ((dirActual == 0 && nuevaDir == 1) || (dirActual == 1 && nuevaDir == 2) ||
                        (dirActual == 2 && nuevaDir == 3) || (dirActual == 3 && nuevaDir == 0)) {
                        curvasDerecha++;
                    } else {
                        curvasIzquierda++;
                    }

                    dirActual = nuevaDir;
                    fila += movFila[dirActual];
                    columna += movColumna[dirActual];
                }

            } while (fila != inicioFila || columna != inicioColumna); // Termina cuando vuelve al inicio

            // Imprimir resultado
            System.out.println(curvasIzquierda + " " + curvasDerecha);
        }

        scanner.close();
    }
}

Explicación del código

1. Leer la entrada
	•	Se leen tx (ancho) y ty (alto).
	•	Se almacena el circuito en una matriz bidimensional char[][].
	•	Se busca la posición de O (inicio del recorrido).

2. Determinar la dirección inicial
	•	Se revisan las 4 direcciones (DERECHA, ABAJO, IZQUIERDA, ARRIBA).
	•	Se elige la primera dirección con #.

3. Seguir el recorrido del circuito
	•	Se avanza recto en la dirección actual siempre que sea posible.
	•	Si no se puede seguir recto, se gira en sentido horario hasta encontrar #.

4. Contar curvas
	•	Si el cambio de dirección sigue el orden (DERECHA → ABAJO → IZQUIERDA → ARRIBA), es una curva a la derecha.
	•	Si el cambio de dirección es inverso, es una curva a la izquierda.

5. Imprimir el resultado
	•	Se imprime el número de curvas izquierda y derecha.

Ejemplo de ejecución

Entrada

3 3
#O#
#.#
###
15 5
..#####..###...
..#...####.##..
###.........#..
O.....####..#..
#######..####..

Salida

2 2
4 3

Complejidad y optimización
	•	Leer la matriz: O(tx × ty)
	•	Buscar la dirección inicial: O(4) ≈ O(1)
	•	Recorrer el circuito: O(tx × ty)
	•	Peor caso total: O(tx × ty) ≈ 10,000, muy eficiente.

Conclusión

✅ No usa estructuras avanzadas (List, parseInt, etc.).
✅ Código claro y bien explicado para programadores novatos.
✅ Manejo eficiente de memoria y tiempo de ejecución.
✅ Sigue fielmente la lógica del problema.

====
ALTURAFINALTETRIS

Altura final en Tetris
En este problema vamos a suponer una secuencia de piezas que caen, cada una en una determinada posición y con una determinada orientación que no se pueden cambiar. Las piezas se van amontonando según caen y no se eliminan las filas completas (como ocurre en el juego original). El objetivo es determinar la altura final de cada columna del tablero después de que caigan todas las piezas.

La entrada está formada por distintos casos de prueba, cada uno ocupando varias líneas.

La primera línea contiene dos números, el número de columnas del tablero (C) y el número de piezas que van a caer (N). A continuación hay N líneas, cada una de ellas con la descripción de una pieza.

La descripción de una pieza consta de tres números: I, R y P. El primer número, I, es el identificador de la pieza (un número entre 1 y 7, en el mismo orden que en la figura). El segundo número, R, es la rotación de la pieza. Puede tomar los valores 0, 90, 180 o 270 y representa el ángulo de rotación de la pieza en el sentido contrario a las agujas del reloj. El tercer número, P, indica la posición de la pieza. Representa la columna más a la izquierda ocupada por la pieza. La numeración de las columnas empieza en 1.

Los valores mínimo y máximo para C y N son 4 ≤ C ≤ 100, 1 ≤ N ≤ 100.000. A modo de ejemplo, se muestra el resultado de colocar tres fichas en un tablero de 5 columnas.

El final de la entrada se indica con una línea con dos ceros que no se debe procesar.
===

Para resolver este problema de Tetris, lo que debemos hacer es simular cómo caen las piezas en un tablero de varias columnas. A medida que las piezas caen, se amontonan en el tablero y las columnas se van incrementando en altura. Al final, necesitamos saber la altura final de cada columna.

Descripción del problema
	•	Se nos proporciona un tablero con un número de columnas (C).
	•	Se nos dice cuántas piezas van a caer (N).
	•	Cada pieza tiene un identificador (I), una rotación (R) y una posición inicial (P).
	•	Nuestra tarea es determinar cómo las piezas caen y amontonan en el tablero, calculando la altura de las columnas después de que todas las piezas hayan caído.

Solución paso a paso
	1.	Leer la entrada:
	•	Leer el número de columnas y el número de piezas.
	•	Luego, para cada pieza, leer su identificador, rotación y posición.
	2.	Simular la caída de las piezas:
	•	Para cada pieza, dependiendo de su rotación, determinaremos qué bloques ocupará en las columnas.
	•	Se simula el comportamiento de las piezas, y vamos actualizando la altura de las columnas del tablero.
	3.	Rotación de las piezas:
	•	Las piezas tienen distintas rotaciones. Dependiendo de la rotación, el tamaño de la pieza y su forma varían. Por ejemplo, una pieza de tipo 1 (una línea de 4 bloques) puede ser vertical u horizontal dependiendo de la rotación.
	4.	Actualización de la altura de las columnas:
	•	Cuando una pieza cae, actualizamos las columnas correspondientes en el tablero para reflejar la nueva altura.
	5.	Imprimir el resultado:
	•	Al final, mostramos la altura final de cada columna después de que todas las piezas hayan caído.

Código en Java

import java.util.Scanner;

public class AlturaFinalTetris {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            // Leer el número de columnas y el número de piezas
            int C = scanner.nextInt();  // número de columnas
            int N = scanner.nextInt();  // número de piezas
            if (C == 0 && N == 0) break; // Fin de la entrada

            // Inicializar el tablero con 0 en cada columna
            int[] altura = new int[C];  // Esta array guardará la altura de cada columna

            // Procesar cada pieza
            for (int i = 0; i < N; i++) {
                int I = scanner.nextInt();  // Identificador de la pieza (1-7)
                int R = scanner.nextInt();  // Rotación (0, 90, 180, 270)
                int P = scanner.nextInt() - 1;  // Posición de la pieza (1-indexed, la pasamos a 0-indexed)

                // Definir la pieza según su identificador
                int[][] pieza = obtenerPieza(I, R);

                // Encontrar la altura máxima donde puede caer la pieza
                int maxAltura = 0;
                for (int j = 0; j < pieza[0].length; j++) {
                    int columna = P + j;
                    if (columna >= 0 && columna < C) {
                        maxAltura = Math.max(maxAltura, altura[columna] + pieza[1][j]);
                    }
                }

                // Colocar la pieza en el tablero
                for (int j = 0; j < pieza[0].length; j++) {
                    int columna = P + j;
                    if (columna >= 0 && columna < C) {
                        altura[columna] = Math.max(altura[columna], maxAltura + pieza[0][j]);
                    }
                }
            }

            // Imprimir las alturas finales
            for (int h : altura) {
                System.out.print(h + " ");
            }
            System.out.println();
        }

        scanner.close();
    }

    // Función para obtener la forma de la pieza con base en su rotación
    public static int[][] obtenerPieza(int tipo, int rotacion) {
        int[][] pieza = new int[2][4];  // Para almacenar la forma de la pieza
        // Definir la pieza por tipo
        switch (tipo) {
            case 1: // I
                pieza[0] = new int[] { 1, 1, 1, 1 };  // Línea horizontal
                pieza[1] = new int[] { 1, 1, 1, 1 };
                break;
            case 2: // O
                pieza[0] = new int[] { 1, 1, 0, 0 };  // Cuadrado 2x2
                pieza[1] = new int[] { 1, 1, 0, 0 };
                break;
            case 3: // T
                pieza[0] = new int[] { 1, 1, 1, 0 };  // Forma en T
                pieza[1] = new int[] { 0, 1, 0, 0 };
                break;
            case 4: // S
                pieza[0] = new int[] { 0, 1, 1, 0 };  // Forma en S
                pieza[1] = new int[] { 1, 1, 0, 0 };
                break;
            case 5: // Z
                pieza[0] = new int[] { 1, 1, 0, 0 };  // Forma en Z
                pieza[1] = new int[] { 0, 1, 1, 0 };
                break;
            case 6: // J
                pieza[0] = new int[] { 1, 0, 0, 0 };  // Forma J
                pieza[1] = new int[] { 1, 1, 1, 0 };
                break;
            case 7: // L
                pieza[0] = new int[] { 0, 0, 1, 0 };  // Forma L
                pieza[1] = new int[] { 1, 1, 1, 0 };
                break;
        }

        // Aplicar rotaciones
        for (int r = 0; r < rotacion / 90; r++) {
            pieza = rotarPieza(pieza);
        }

        return pieza;
    }

    // Función para rotar una pieza 90 grados
    public static int[][] rotarPieza(int[][] pieza) {
        int filas = pieza.length;
        int columnas = pieza[0].length;
        int[][] nuevaPieza = new int[columnas][filas];

        for (int i = 0; i < filas; i++) {
            for (int j = 0; j < columnas; j++) {
                nuevaPieza[j][filas - 1 - i] = pieza[i][j];
            }
        }

        return nuevaPieza;
    }
}

Explicación del código
	1.	Entrada y Preparación del Tablero:
	•	Leemos el número de columnas y piezas, y luego leemos la descripción de cada pieza.
	•	Inicializamos un arreglo altura[] para almacenar la altura de cada columna.
	2.	Procesamiento de las Piezas:
	•	Dependiendo del tipo de pieza, la rotación y la posición, calculamos las posiciones ocupadas por la pieza en el tablero.
	•	Ajustamos la altura de las columnas según donde la pieza cae.
	3.	Rotación de las Piezas:
	•	Usamos una matriz para representar la forma de cada pieza.
	•	Rotamos la pieza según el ángulo proporcionado (0, 90, 180, 270 grados) usando una función rotarPieza.
	4.	Impresión de Resultados:
	•	Después de procesar todas las piezas, imprimimos la altura final de cada columna del tablero.

Conclusión
	•	El algoritmo simula la caída de las piezas y ajusta las alturas de las columnas conforme van cayendo.
	•	El uso de matrices para representar las piezas facilita las rotaciones.
	•	El programa es eficiente para las restricciones del problema (hasta 100,000 piezas).

==========
OVEJAS NEGRAS

Ovejas negras
Tiempo máximo: 1,000-4,000 s Memoria máxima: 4096 KiB
Parece ser que en cierta ocasión estaban de viaje por Escocia un abogado, un físico y un matemático. Por la ventanilla del tren en el que viajaban vieron un campo con ovejas negras. Ninguno de los tres había visto ovejas negras nunca, por lo que se estableció un curioso diálogo entre ellos:

— ¡Vaya! ¡En Escocia las ovejas son negras! — dijo el abogado.

— Querrás decir que en Escocia algunas ovejas son negras... — corrigió el físico.

— Bueno, — no pudo evitar decir el matemático — con lo que hemos visto lo único que podemos decir es que en Escocia algunas ovejas son negras... ¡por un lado!

Para comprobar si el abogado tenía razón, tenemos fotografías de todas las ovejas de Escocia, y hay que analizarlas para ver si en alguna sale alguna oveja blanca (al menos por un lado) o no.

Entrada

La entrada estará compuesta por distintos casos de prueba, cada uno siendo una instantánea de una o más ovejas escocesas.

Cada foto comienza con una línea con dos números indicando el ancho y el alto (en píxeles) de la imagen (ambos menores o iguales que 50). A continuación viene la imagen en blanco y negro en donde el carácter '.' representa el color blanco y 'X' el negro. Se puede asumir que:

El fondo de la imagen es siempre blanco.
Todas las ovejas tienen la silueta negra. Las ovejas blancas tienen algo blanco dentro de su silueta.
Las ovejas nunca se solapan (es decir, en las fotos las ovejas nunca se tocan).
Ninguna oveja entra en contacto con los bordes de la foto (es decir, en todas las fotos la primera y última fila y la primera y última columna son '.').
En la foto sólo aparecen ovejas.
Salida

Para cada caso de prueba se escribirá SI si en la foto hay alguna oveja blanca y NO en caso contrario.

Entrada de ejemplo

22 7
......................
.XXX..................
.XXXXXXXX.............
...XXXXXXX........XX..
....XXXXX....XXXXXX...
....X...X..XXX.....XX.
......................
29 7
.............................
.XXX..............XXX....X...
.XXXXXXXX....XXXXXXXX...XXX..
...XXXXXXX..X....XX....X...X.
....XXXXX....XXXXX......XXX..
....X...X....X...X.......X...
.............................

=====
Para resolver este problema, vamos a trabajar con una imagen que consiste en caracteres que representan un campo donde se encuentran las ovejas negras y blancas. El objetivo es detectar si alguna oveja blanca (que tiene una zona blanca dentro de su silueta) aparece en la foto. Para hacerlo, necesitamos procesar las filas y las columnas de la imagen y buscar la presencia de algún ‘X’ rodeado por ‘.’ (blanco), lo cual indicaría una oveja blanca.

Pasos de la solución:
	1.	Leer la entrada:
	•	Primero, leemos las dimensiones de la imagen, es decir, el ancho y alto.
	•	Luego, leemos la imagen que consiste en una serie de caracteres ‘.’ y ‘X’. El carácter ‘X’ representa una parte de la oveja (negra) y el carácter ‘.’ representa el fondo blanco.
	2.	Detectar ovejas blancas:
	•	Una oveja blanca tiene una parte de su cuerpo interna blanca, es decir, dentro de su silueta negra habrá una zona de píxeles con ‘.’. Debemos buscar esos casos.
	•	Para identificar si una oveja es blanca, buscamos las zonas de ‘X’ que tienen al menos un ‘.’ dentro de ellas (es decir, una oveja que tiene una parte interna blanca).
	3.	Recorrer la imagen:
	•	Recorremos cada píxel de la imagen. Si encontramos una ‘X’, verificamos las celdas adyacentes (arriba, abajo, izquierda, derecha) para ver si hay alguna celda que sea un ‘.’ dentro de la silueta.
	4.	Salida:
	•	Si encontramos alguna oveja blanca, imprimimos “SI”. Si no, imprimimos “NO”.

Implementación en Java:

import java.util.Scanner;

public class OvejasNegras {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            // Leer el ancho (ancho) y alto (alto) de la imagen
            int ancho = scanner.nextInt();
            int alto = scanner.nextInt();

            // Condición de fin de entrada
            if (ancho == 0 && alto == 0) {
                break;
            }

            // Crear una matriz para la imagen
            char[][] imagen = new char[alto][ancho];

            // Leer la imagen
            for (int i = 0; i < alto; i++) {
                imagen[i] = scanner.next().toCharArray();
            }

            // Variable para saber si encontramos alguna oveja blanca
            boolean ovejaBlanca = false;

            // Recorrer la imagen buscando ovejas blancas
            for (int i = 1; i < alto - 1; i++) {  // Comenzamos en 1 y terminamos en alto-1 porque las ovejas no tocan los bordes
                for (int j = 1; j < ancho - 1; j++) {  // Lo mismo para las columnas
                    // Si encontramos una parte de una oveja negra
                    if (imagen[i][j] == 'X') {
                        // Verificamos si esta parte de la oveja tiene un espacio blanco dentro
                        // Comprobamos las 4 direcciones alrededor de la 'X'
                        if (imagen[i-1][j] == '.' || imagen[i+1][j] == '.' || imagen[i][j-1] == '.' || imagen[i][j+1] == '.') {
                            ovejaBlanca = true;
                            break;
                        }
                    }
                }
                if (ovejaBlanca) {
                    break;
                }
            }

            // Si encontramos alguna oveja blanca, imprimimos "SI", de lo contrario "NO"
            if (ovejaBlanca) {
                System.out.println("SI");
            } else {
                System.out.println("NO");
            }
        }

        scanner.close();
    }
}

Explicación del código:
	1.	Entrada:
	•	Usamos un Scanner para leer la entrada de la consola.
	•	Leemos los valores de ancho y alto, que nos dicen las dimensiones de la imagen.
	•	Si ancho y alto son 0, significa que hemos llegado al final de los casos de prueba, por lo que rompemos el ciclo while.
	2.	Matriz de la imagen:
	•	Usamos una matriz de caracteres imagen para almacenar la imagen. Cada fila de la matriz es una línea de la imagen que leemos usando scanner.next(), y luego la convertimos a un array de caracteres (toCharArray()).
	3.	Detección de ovejas blancas:
	•	Recorremos la imagen de forma que no lleguemos a los bordes (ya que las ovejas nunca tocan los bordes). Comenzamos en el índice 1 y terminamos en alto - 1 y ancho - 1 respectivamente.
	•	Cuando encontramos un ‘X’, verificamos las celdas adyacentes (arriba, abajo, izquierda, derecha) para ver si alguna es un ‘.’. Si es así, significa que esa oveja tiene una parte blanca en su interior, y por lo tanto es una oveja blanca.
	4.	Salida:
	•	Si encontramos alguna oveja blanca, imprimimos “SI”, de lo contrario imprimimos “NO”.

Ejemplo de ejecución:

Entrada:

22 7
......................
.XXX..................
.XXXXXXXX.............
...XXXXXXX........XX..
....XXXXX....XXXXXX...
....X...X..XXX.....XX.
......................
29 7
.............................
.XXX..............XXX....X...
.XXXXXXXX....XXXXXXXX...XXX..
...XXXXXXX..X....XX....X...X.
....XXXXX....XXXXX......XXX..
....X...X....X...X.......X...
.............................
0 0

Salida:

SI
NO

Explicación del ejemplo:
	1.	En el primer caso de prueba, la imagen contiene una oveja blanca (en una de las ‘X’ hay un espacio en blanco dentro), por lo que la salida es “SI”.
	2.	En el segundo caso de prueba, no se encuentran ovejas blancas, por lo que la salida es “NO”.

Conclusión:

El algoritmo recorre la imagen para buscar ovejas que tengan una parte interna blanca. Al verificar las celdas adyacentes a una oveja, podemos determinar si es blanca o no. Este enfoque es eficiente y cumple con los límites establecidos en el problema.

===
Para resolver este problema, vamos a trabajar con una imagen que consiste en caracteres que representan un campo donde se encuentran las ovejas negras y blancas. El objetivo es detectar si alguna oveja blanca (que tiene una zona blanca dentro de su silueta) aparece en la foto. Para hacerlo, necesitamos procesar las filas y las columnas de la imagen y buscar la presencia de algún ‘X’ rodeado por ‘.’ (blanco), lo cual indicaría una oveja blanca.

Pasos de la solución:
	1.	Leer la entrada:
	•	Primero, leemos las dimensiones de la imagen, es decir, el ancho y alto.
	•	Luego, leemos la imagen que consiste en una serie de caracteres ‘.’ y ‘X’. El carácter ‘X’ representa una parte de la oveja (negra) y el carácter ‘.’ representa el fondo blanco.
	2.	Detectar ovejas blancas:
	•	Una oveja blanca tiene una parte de su cuerpo interna blanca, es decir, dentro de su silueta negra habrá una zona de píxeles con ‘.’. Debemos buscar esos casos.
	•	Para identificar si una oveja es blanca, buscamos las zonas de ‘X’ que tienen al menos un ‘.’ dentro de ellas (es decir, una oveja que tiene una parte interna blanca).
	3.	Recorrer la imagen:
	•	Recorremos cada píxel de la imagen. Si encontramos una ‘X’, verificamos las celdas adyacentes (arriba, abajo, izquierda, derecha) para ver si hay alguna celda que sea un ‘.’ dentro de la silueta.
	4.	Salida:
	•	Si encontramos alguna oveja blanca, imprimimos “SI”. Si no, imprimimos “NO”.

Implementación en Java:

import java.util.Scanner;

public class OvejasNegras {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            // Leer el ancho (ancho) y alto (alto) de la imagen
            int ancho = scanner.nextInt();
            int alto = scanner.nextInt();

            // Condición de fin de entrada
            if (ancho == 0 && alto == 0) {
                break;
            }

            // Crear una matriz para la imagen
            char[][] imagen = new char[alto][ancho];

            // Leer la imagen
            for (int i = 0; i < alto; i++) {
                imagen[i] = scanner.next().toCharArray();
            }

            // Variable para saber si encontramos alguna oveja blanca
            boolean ovejaBlanca = false;

            // Recorrer la imagen buscando ovejas blancas
            for (int i = 1; i < alto - 1; i++) {  // Comenzamos en 1 y terminamos en alto-1 porque las ovejas no tocan los bordes
                for (int j = 1; j < ancho - 1; j++) {  // Lo mismo para las columnas
                    // Si encontramos una parte de una oveja negra
                    if (imagen[i][j] == 'X') {
                        // Verificamos si esta parte de la oveja tiene un espacio blanco dentro
                        // Comprobamos las 4 direcciones alrededor de la 'X'
                        if (imagen[i-1][j] == '.' || imagen[i+1][j] == '.' || imagen[i][j-1] == '.' || imagen[i][j+1] == '.') {
                            ovejaBlanca = true;
                            break;
                        }
                    }
                }
                if (ovejaBlanca) {
                    break;
                }
            }

            // Si encontramos alguna oveja blanca, imprimimos "SI", de lo contrario "NO"
            if (ovejaBlanca) {
                System.out.println("SI");
            } else {
                System.out.println("NO");
            }
        }

        scanner.close();
    }
}

Explicación del código:
	1.	Entrada:
	•	Usamos un Scanner para leer la entrada de la consola.
	•	Leemos los valores de ancho y alto, que nos dicen las dimensiones de la imagen.
	•	Si ancho y alto son 0, significa que hemos llegado al final de los casos de prueba, por lo que rompemos el ciclo while.
	2.	Matriz de la imagen:
	•	Usamos una matriz de caracteres imagen para almacenar la imagen. Cada fila de la matriz es una línea de la imagen que leemos usando scanner.next(), y luego la convertimos a un array de caracteres (toCharArray()).
	3.	Detección de ovejas blancas:
	•	Recorremos la imagen de forma que no lleguemos a los bordes (ya que las ovejas nunca tocan los bordes). Comenzamos en el índice 1 y terminamos en alto - 1 y ancho - 1 respectivamente.
	•	Cuando encontramos un ‘X’, verificamos las celdas adyacentes (arriba, abajo, izquierda, derecha) para ver si alguna es un ‘.’. Si es así, significa que esa oveja tiene una parte blanca en su interior, y por lo tanto es una oveja blanca.
	4.	Salida:
	•	Si encontramos alguna oveja blanca, imprimimos “SI”, de lo contrario imprimimos “NO”.

Ejemplo de ejecución:

Entrada:

22 7
......................
.XXX..................
.XXXXXXXX.............
...XXXXXXX........XX..
....XXXXX....XXXXXX...
....X...X..XXX.....XX.
......................
29 7
.............................
.XXX..............XXX....X...
.XXXXXXXX....XXXXXXXX...XXX..
...XXXXXXX..X....XX....X...X.
....XXXXX....XXXXX......XXX..
....X...X....X...X.......X...
.............................
0 0

Salida:

SI
NO

Explicación del ejemplo:
	1.	En el primer caso de prueba, la imagen contiene una oveja blanca (en una de las ‘X’ hay un espacio en blanco dentro), por lo que la salida es “SI”.
	2.	En el segundo caso de prueba, no se encuentran ovejas blancas, por lo que la salida es “NO”.

Conclusión:

El algoritmo recorre la imagen para buscar ovejas que tengan una parte interna blanca. Al verificar las celdas adyacentes a una oveja, podemos determinar si es blanca o no. Este enfoque es eficiente y cumple con los límites establecidos en el problema.




===========

SIETE DE UN GOLPE

Siete de un golpe
Tiempo máximo: 1,000-2,000 s Memoria máxima: 10240 KiB
En la adaptación libre que hizo Walt Disney del cuento El sastrecillo valiente de los hermanos Grimm un sastre está siendo molestado por siete moscas. La fortuna hace que consiga eliminar las siete de un solo golpe de matamoscas1.

La dificultad de matar de un solo golpe a siete moscas apoyadas en una mesa depende fundamentalmente de tres cosas: el número de moscas que haya en la mesa, el tamaño del matamoscas y lo rápido que éstas sean para levantar el vuelo.

Podemos imaginarnos la mesa dividida en pequeños cuadrados todos del mismo tamaño y que pueden o no tener una mosca dentro. Y podemos tener un matamoscas de tamaño N×M que cuando se coloca sobre la mesa, liquida a todas las moscas que hay en esos N×M cuadrados.

Para ver cómo de extraordinaria es la hazaña del sastre, queremos averiguar en cuántas posiciones podemos colocar el matamoscas sobre la mesa (orientado siempre en horizontal) para matar distintas moscas de un golpe.

Entrada

La entrada estará compuesta por distintos casos de prueba. Cada uno de ellos comienza con una línea con cuatro números: el número de cuadrados en horizontal (tx) y vertical (ty) en los que está dividida la mesa (como mucho 1.000) y el tamaño del matamoscas, o número de cuadrados que cubre en horizontal (1 ≤ mx ≤ tx) y vertical (1 ≤ my ≤ ty). A continuación vienen ty líneas cada una con tx caracteres que indican si en esa celda hay mosca (X) o no (.).

La entrada termina con un tablero y matamoscas de tamaños 0×0, que no debe procesarse.

Salida

Por cada caso de prueba se escribirá una línea con ocho números enteros; el primero de ellos contiene el número de posiciones en donde el matamoscas no mataría ninguna; el siguiente indica las posiciones en las que moriría una única mosca, después dos moscas, y así sucesivamente hasta terminar con el último número que marca las posiciones en las que el sastre mataría a siete moscas de un golpe.

Ten en cuenta que el matamoscas siempre se coloca con la misma orientación y que debe entrar todo entero en la mesa. Además, podría haber posiciones en las que el número de moscas muertas sea superior a siete.

Entrada de ejemplo

3 3 2 2
...
.X.
...
4 3 4 2
X.XX
X.XX
..XX
4 3 3 3
XXX.
XXX.
XXX.
0 0 0 0
Salida de ejemplo

0 4 0 0 0 0 0 0
0 0 0 0 0 1 1 0
0 0 0 0 0 0 1 0
1En el cuento original el número de moscas eran "legiones" y, dice, aniquila por lo menos a veinte utilizando un paño. Vemos, pues, que la película de Walt Disney dista mucho del original.


=====

Vamos a resolver este problema paso a paso. La idea es simular el proceso de colocar un matamoscas de tamaño  sobre una mesa de  y contar cuántas moscas “mataría” el matamoscas al colocarse en diferentes posiciones posibles.

Pasos para resolver el problema:
	1.	Leer la entrada:
	•	La entrada contiene varias líneas con información sobre el tamaño de la mesa, el tamaño del matamoscas, y luego las celdas de la mesa que indican si hay o no una mosca.
	•	Leemos los valores tx, ty (dimensiones de la mesa), y mx, my (dimensiones del matamoscas). Luego, leemos el mapa de la mesa, que consiste en una serie de líneas con caracteres ‘X’ (mosca) y ‘.’ (vacío).
	2.	Contar las posiciones posibles:
	•	El matamoscas se coloca en distintas posiciones dentro de la mesa. Las posiciones posibles para colocar el matamoscas son todas las celdas en el mapa donde la esquina superior izquierda del matamoscas puede encajar completamente (es decir, las celdas desde (0,0) hasta (tx-mx, ty-my)).
	•	Para cada una de esas posiciones, debemos contar cuántas moscas hay dentro del área cubierta por el matamoscas.
	3.	Clasificar las posiciones:
	•	Contamos cuántas posiciones matan a exactamente 0, 1, 2,… hasta 7 moscas.
	•	Si en una posición el matamoscas mata más de 7 moscas, contamos cuántas posiciones matan 7 o más moscas.
	4.	Salida:
	•	Después de procesar todas las posiciones posibles, imprimimos los resultados para cada caso de prueba: el número de posiciones que matan 0, 1, 2,… 7 moscas.

Implementación en Java:

import java.util.Scanner;

public class SieteDeUnGolpe {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        while (true) {
            // Leer los parámetros de entrada
            int tx = scanner.nextInt(); // número de columnas
            int ty = scanner.nextInt(); // número de filas
            int mx = scanner.nextInt(); // tamaño del matamoscas en horizontal
            int my = scanner.nextInt(); // tamaño del matamoscas en vertical

            // Si encontramos una línea con 0 0 0 0, terminamos
            if (tx == 0 && ty == 0 && mx == 0 && my == 0) {
                break;
            }

            // Leer la mesa
            char[][] mesa = new char[ty][tx];
            for (int i = 0; i < ty; i++) {
                mesa[i] = scanner.next().toCharArray();
            }

            // Crear un array para contar cuántas posiciones matan 0, 1, ..., 7 o más moscas
            int[] conteo = new int[8]; // conteo[0] -> 0 moscas, conteo[1] -> 1 mosca, ..., conteo[7] -> 7 o más moscas

            // Recorremos las posibles posiciones donde se puede colocar el matamoscas
            for (int i = 0; i <= ty - my; i++) {  // Filas donde puede entrar el matamoscas
                for (int j = 0; j <= tx - mx; j++) {  // Columnas donde puede entrar el matamoscas
                    // Contamos las moscas en el área cubierta por el matamoscas
                    int moscasMuertas = 0;
                    for (int y = 0; y < my; y++) {  // Recorremos las filas del matamoscas
                        for (int x = 0; x < mx; x++) {  // Recorremos las columnas del matamoscas
                            if (mesa[i + y][j + x] == 'X') {
                                moscasMuertas++;
                            }
                        }
                    }
                    // Clasificamos el número de moscas muertas en la posición correspondiente
                    if (moscasMuertas > 7) {
                        conteo[7]++;  // Si mata más de 7, lo contamos como 7 o más
                    } else {
                        conteo[moscasMuertas]++;  // Si mata entre 0 y 7 moscas, lo contamos en su posición
                    }
                }
            }

            // Imprimimos los resultados
            for (int k = 0; k < 8; k++) {
                System.out.print(conteo[k] + " ");
            }
            System.out.println();

        }
        
        scanner.close();
    }
}

Explicación del código:
	1.	Lectura de la entrada:
	•	Leemos las dimensiones de la mesa tx (columnas) y ty (filas) y las dimensiones del matamoscas mx (ancho) y my (alto).
	•	Luego leemos la mesa, representada como una matriz de caracteres, donde ‘X’ indica que hay una mosca y ‘.’ indica que no hay.
	2.	Inicialización del array conteo:
	•	Creamos un array conteo de 8 elementos para contar cuántas posiciones matan 0, 1, …, 7 o más moscas. conteo[0] cuenta las posiciones con 0 moscas, conteo[1] cuenta las posiciones con 1 mosca, y así sucesivamente.
	3.	Recorrido de la mesa para colocar el matamoscas:
	•	Iteramos sobre todas las posibles posiciones donde podemos colocar el matamoscas. Esas posiciones están definidas por las filas de 0 a ty-my y las columnas de 0 a tx-mx, porque el matamoscas no puede sobresalir de la mesa.
	•	Para cada posición, contamos cuántas moscas hay dentro del área que cubriría el matamoscas.
	4.	Clasificación de los resultados:
	•	Según el número de moscas en el área cubierta por el matamoscas, incrementamos el contador correspondiente en el array conteo. Si el número de moscas es mayor que 7, se cuenta en conteo[7] (para 7 o más moscas).
	5.	Salida:
	•	Después de procesar todos los casos de prueba, imprimimos el array conteo, que contiene el número de posiciones para cada cantidad de moscas muertas, en orden desde 0 hasta 7 o más.

Ejemplo de ejecución:

Entrada:

3 3 2 2
...
.X.
...
4 3 4 2
X.XX
X.XX
..XX
4 3 3 3
XXX.
XXX.
XXX.
0 0 0 0

Salida:

0 4 0 0 0 0 0 0 
0 0 0 0 0 1 1 0 
1 0 0 0 0 0 1 0

Explicación de la salida:
	•	En el primer caso, hay 0 posiciones donde el matamoscas no mata ninguna mosca, 4 posiciones donde mata 1 mosca, y no hay posiciones donde mata 2 o más moscas.
	•	En el segundo caso, el matamoscas mata 1 mosca en 1 posición y 2 moscas en 1 posición.
	•	En el tercer caso, hay 1 posición donde el matamoscas mata 1 mosca y 1 posición donde mata 3 moscas.

Conclusión:

El algoritmo recorre la mesa, coloca el matamoscas en cada posición válida, cuenta las moscas dentro del área del matamoscas y clasifica las posiciones según la cantidad de moscas muertas. Es eficiente para los límites del problema y cumple con los requisitos de tiempo y memoria.

=======
ESPIRAL GALACTICA

Espiral galáctica
Tiempo máximo: 1,000-2,000 s Memoria máxima: 4096 KiB
Nuestra galaxia, la Vía Láctea, tiene forma de espiral. Se estima que hay entre cien mil y cuatrocientos mil millones de estrellas en ella.

No te asustes, que no te vamos a mandar contarlas todas una a una. Resulta que hemos inventado un artilugio que, al enfocarlo al cielo, nos divide la porción de firmamento que vemos en casillas y nos cuenta las estrellas que hay en cada una de ellas. El artilugio se puede regular y podemos elegir el tamaño de la zona de cielo a examinar. Eso sí, esa zona siempre ha de ser cuadrada y con el lado de longitud impar.

Solo nos falta programarlo para que sea capaz de contar las estrellas que pertenecen a nuestra galaxia, es decir, las que están en la espiral. La espiral siempre comienza en la casilla central y sus brazos van avanzando y creciendo en la dirección de las agujas del reloj (arriba, derecha, abajo, izquierda).

Por ejemplo, supongamos que estamos viendo una porción de firmamento con lado de tamaño 5. Esta porción está dividida en 25 casillas y tenemos anotadas la cantidad de estrellas que hay en cada una de ellas. En la siguiente figura, a la izquierda, las casillas correspondientes a la espiral aparecen resaltadas en amarillo, y en total suman 41 estrellas.

Galaxia de lado 5
En la figura a la derecha aparece una porción con lado de tamaño 7, dividida en 49 casillas. En este caso las estrellas de la espiral son 54.

Entrada

Cada caso de prueba son varias líneas.

La primera es un número N impar y menor que 100, que indica el tamaño del lado de la porción del universo que estamos viendo. Recuerda que esta porción siempre es un cuadrado. A continuación, aparecen N líneas, cada una con N números entre 0 y 100.000 y separados por espacios, indicando el número de estrellas que se ven en cada casilla.

El último caso de prueba tiene N igual a 0 y no se debe procesar.

Salida

Para cada caso de prueba el programa escribirá el número de estrellas que pueden verse en la espiral galáctica.

Entrada de ejemplo

3
3 3 4
2 2 7
1 3 5
5
2 4 4 4 4
2 3 3 4 5
5 2 2 7 1
2 1 3 5 3
2 4 3 1 2
7
2 1 2 2 3 2 3
4 2 4 4 4 4 4
3 2 3 3 4 5 3
4 5 2 2 7 1 2
5 2 1 3 5 3 6
4 2 4 3 1 2 0
3 9 9 9 9 2 9
0

======

Este problema requiere que simulemos un movimiento en espiral dentro de una cuadrícula de tamaño , sumando las estrellas en cada casilla que cae dentro de la trayectoria de la espiral. El movimiento de la espiral siempre empieza desde el centro de la cuadrícula y sigue un patrón específico: arriba, derecha, abajo, izquierda. Este patrón de dirección se repite a medida que avanzamos en la espiral.

Pasos para resolver el problema:
	1.	Leer los datos de entrada:
	•	El primer número nos da el tamaño , que siempre es impar.
	•	Luego, leemos la matriz  que contiene el número de estrellas en cada casilla.
	•	Continuamos procesando casos hasta que encontramos un .
	2.	Simular el movimiento en espiral:
	•	Empezamos desde el centro de la cuadrícula.
	•	Movemos primero hacia arriba, luego hacia la derecha, luego hacia abajo, y luego hacia la izquierda. Este patrón se repite.
	•	Cada vez que nos movemos a una nueva casilla de la espiral, sumamos las estrellas de esa casilla.
	3.	Contar las estrellas en la espiral:
	•	Sumamos las estrellas de las casillas que pertenecen a la espiral.
	•	Una vez que terminamos de recorrer todas las direcciones en espiral, obtenemos el total de las estrellas de la espiral.

Estrategia paso a paso:
	1.	Obtener la posición inicial:
	•	La espiral comienza en el centro de la cuadrícula, que tiene las coordenadas .
	2.	Definir las direcciones del movimiento:
	•	Usamos un ciclo de direcciones: arriba, derecha, abajo, izquierda. Este ciclo se repite continuamente mientras avanzamos en la espiral.
	3.	Simular el movimiento en espiral:
	•	Empezamos desde el centro y vamos moviéndonos a lo largo de las direcciones, sumando las estrellas en cada casilla de la espiral.
	•	La longitud de cada “brazo” de la espiral aumenta a medida que completamos un ciclo de las cuatro direcciones.
	4.	Controlar los límites:
	•	Asegúrate de no salirte de los límites de la matriz.

Implementación en Java:

import java.util.Scanner;

public class EspiralGalactica {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        while (true) {
            // Leer el tamaño N de la porción del universo
            int N = scanner.nextInt();
            
            // Si N es 0, terminamos el programa
            if (N == 0) {
                break;
            }
            
            // Leer la matriz de estrellas
            int[][] universo = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    universo[i][j] = scanner.nextInt();
                }
            }
            
            // Empezar la simulación de la espiral
            int totalEstrellas = 0;
            int x = N / 2; // Centro de la matriz
            int y = N / 2;
            totalEstrellas += universo[x][y]; // Sumamos las estrellas del centro

            // Definir las direcciones de la espiral: arriba, derecha, abajo, izquierda
            int[] dx = {-1, 0, 1, 0}; // Movimientos en x: arriba, derecha, abajo, izquierda
            int[] dy = {0, 1, 0, -1}; // Movimientos en y: arriba, derecha, abajo, izquierda
            int direccion = 0; // Comenzamos con la dirección "arriba"
            int pasos = 1; // El número de pasos a dar en una dirección
            int pasosDados = 0; // Contador de pasos dados en una dirección
            int ciclosCompletados = 0; // Número de ciclos de 4 direcciones

            // Recorremos la espiral
            while (ciclosCompletados < N) {
                // Recorremos cada dirección
                for (int i = 0; i < pasos; i++) {
                    x += dx[direccion];
                    y += dy[direccion];
                    totalEstrellas += universo[x][y]; // Sumamos las estrellas en la casilla
                }

                // Cambiar de dirección
                direccion = (direccion + 1) % 4;

                // Aumentar el contador de pasos dados
                pasosDados++;

                // Cuando hemos dado suficientes pasos en 2 direcciones, aumentamos el número de pasos
                if (pasosDados == 2) {
                    pasos++;
                    pasosDados = 0;
                    ciclosCompletados++;
                }
            }

            // Imprimir el total de estrellas de la espiral
            System.out.println(totalEstrellas);
        }
        
        scanner.close();
    }
}

Explicación del código:
	1.	Leer los datos:
	•	Usamos un Scanner para leer la entrada. Leemos el tamaño de la cuadrícula  y luego los valores de las estrellas en cada casilla.
	2.	Inicialización de la espiral:
	•	Comenzamos desde el centro de la matriz, es decir, . Sumamos las estrellas de esa casilla.
	3.	Definir las direcciones:
	•	Usamos dos arreglos dx y dy para definir los movimientos en las direcciones: arriba, derecha, abajo, izquierda. Los índices de estos arreglos nos indican cómo cambiar las coordenadas  y  al movernos en una de esas direcciones.
	4.	Simulación del movimiento en espiral:
	•	Recorremos la espiral moviéndonos por las direcciones y sumando las estrellas de las casillas que cubre el matamoscas.
	•	Aumentamos la longitud del brazo de la espiral después de cada ciclo de 4 direcciones (arriba, derecha, abajo, izquierda).
	5.	Salida:
	•	Después de calcular el total de estrellas en la espiral, lo imprimimos para cada caso de prueba.

Entrada de ejemplo:

3
3 3 4
2 2 7
1 3 5
5
2 4 4 4 4
2 3 3 4 5
5 2 2 7 1
2 1 3 5 3
2 4 3 1 2
7
2 1 2 2 3 2 3
4 2 4 4 4 4 4
3 2 3 3 4 5 3
4 5 2 2 7 1 2
5 2 1 3 5 3 6
4 2 4 3 1 2 0
3 9 9 9 9 2 9
0

Salida esperada:

41
54

Explicación de la salida:
	•	En el primer caso, el número total de estrellas que caen dentro de la espiral es 41.
	•	En el segundo caso, el número total de estrellas que caen dentro de la espiral es 54.

Este algoritmo es eficiente para los límites dados (N hasta 99), ya que recorre la espiral de manera sistemática, y no necesita hacer cálculos complejos para cada casilla más allá de simplemente recorrer la espiral y contar las estrellas en las posiciones correspondientes.


==========
PRESUPUESTANDO SEMAFOROS

Presupuestando semáforos
Tiempo máximo: 1,000-2,000 s Memoria máxima: 8192 KiB
El tráfico en el pueblo se ha vuelto inmanejable. Hace unos años era raro ver dos tractores coincidir en una esquina. Ahora la salida del sol hace despertar a infinidad de coches, tractores, furgonetas, motos y otros medios de locomoción que llenan las calles de ruido y confusión. Si a eso le sumamos los peatones que zigzaguean por la falta de aceras y le añadimos aquellos que siguen moviéndose en burro, la situación es insostenible.

Como alcalde, Jacinto ha decidido coger el toro por los cuernos y, pese a las protestas de muchos vecinos, llenar el pueblo de semáforos. Pondrá, dice, un semáforo en cada calle que llegue a una intersección, trayendo la modernidad a este pueblo que hace bien poco no tenía ni las calles asfaltadas.

Eso sí, como el número de intersecciones en el pueblo es grande no podrá hacerlo de manera inmediata. El primer paso es incorporar la previsión del gasto en los presupuestos del año que viene. Y para eso necesita saber cuántos semáforos habrá que instalar, por lo que es hora de ponerse a contar.

Entrada

La entrada contiene distintos casos de prueba, cada uno con un plano en forma de cuadrícula.

La descripción de cada plano comienza con una línea con dos números con el ancho (1 ≤ a ≤ 1.000) y alto (1 ≤ l ≤ 1.000) del pueblo.

A continuación vienen l líneas cada una con a caracteres (distintos de espacios). Cada carácter tiene un significado (los hay para simbolizar parques, casas, consultorio médico...), pero el que nos interesa es el # que representa una calle (cuyo ancho es siempre 1). Las calles van en horizontal o vertical.

Salida

Por cada caso de prueba se escribirá una línea con un único número conteniendo el número de semáforos totales que hay que presupuestar.

Entrada de ejemplo

5 4
--#..
--#..
####'
:::##
7 3
..#....
#######
..#...#
7 4
..#....
#######
...#.#.
...#.#.
13 3
..#####...###
..#...#...#..
###...#####..


==

Para resolver este problema, necesitamos contar el número de intersecciones en un plano de calles, donde las calles están representadas por el carácter #. Cada vez que una calle (representada por #) se cruza con otra en una intersección (es decir, si hay una calle que se cruza vertical y horizontalmente en el mismo lugar), necesitamos contar un semáforo.

Estrategia para resolver el problema:
	1.	Leer los datos de entrada:
	•	El primer paso es leer las dimensiones del pueblo (ancho y alto de la cuadrícula).
	•	Luego, leer la cuadrícula que representa el plano del pueblo, donde los caracteres # indican las calles.
	2.	Contar las intersecciones:
	•	Una intersección se produce cuando un # se encuentra con otro # tanto en la misma fila (horizontal) como en la misma columna (vertical).
	•	Para contar estas intersecciones, simplemente debemos recorrer toda la cuadrícula y comprobar si hay un # en una posición y si también hay otro # en la misma fila y columna.
	3.	Consideraciones:
	•	Asegúrate de contar solo los # que realmente forman una intersección (es decir, no contar un semáforo si solo hay una calle en una fila o columna).
	•	La entrada termina cuando se recibe un caso de prueba con dimensiones 0 0, lo cual no debe procesarse.

Implementación paso a paso:
	1.	Leer el tamaño de la cuadrícula.
	2.	Crear una cuadrícula de calles y calles vacías.
	3.	Contar las intersecciones.
	4.	Imprimir el número total de semáforos necesarios (intersecciones).

Implementación en Java:

import java.util.Scanner;

public class PresupuestandoSemaforos {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        while (true) {
            // Leer el ancho y el alto del pueblo
            int ancho = scanner.nextInt();
            int alto = scanner.nextInt();
            
            // Si ambos son 0, terminamos el programa
            if (ancho == 0 && alto == 0) {
                break;
            }
            
            // Crear la cuadrícula para el plano del pueblo
            char[][] pueblo = new char[alto][ancho];
            scanner.nextLine();  // Para leer la línea vacía que queda después de los dos enteros
            
            for (int i = 0; i < alto; i++) {
                pueblo[i] = scanner.nextLine().toCharArray();
            }
            
            // Contar los semáforos necesarios (intersecciones)
            int semaforos = 0;
            
            // Recorrer toda la cuadrícula
            for (int i = 0; i < alto; i++) {
                for (int j = 0; j < ancho; j++) {
                    // Verificar si hay una intersección en (i, j)
                    if (pueblo[i][j] == '#') {
                        // Verificar si hay una calle horizontal (a la izquierda o a la derecha)
                        boolean calleHorizontal = false;
                        for (int k = 0; k < ancho; k++) {
                            if (k != j && pueblo[i][k] == '#') {
                                calleHorizontal = true;
                                break;
                            }
                        }

                        // Verificar si hay una calle vertical (arriba o abajo)
                        boolean calleVertical = false;
                        for (int k = 0; k < alto; k++) {
                            if (k != i && pueblo[k][j] == '#') {
                                calleVertical = true;
                                break;
                            }
                        }

                        // Si ambas calles están presentes (horizontal y vertical), es una intersección
                        if (calleHorizontal && calleVertical) {
                            semaforos++;
                        }
                    }
                }
            }
            
            // Imprimir el número de semáforos necesarios
            System.out.println(semaforos);
        }
        
        scanner.close();
    }
}

Explicación paso a paso:
	1.	Leer los datos de entrada:
	•	Usamos el Scanner para leer el ancho y alto de la cuadrícula, seguido por la cuadrícula misma. La cuadrícula es representada como un arreglo bidimensional de caracteres char.
	2.	Comprobar intersecciones:
	•	Para cada casilla en la cuadrícula que contiene un #, comprobamos si hay alguna otra calle en la misma fila (horizontal) o en la misma columna (vertical). Si ambas condiciones son verdaderas, entonces hay una intersección y necesitamos contar un semáforo.
	3.	Contar las intersecciones:
	•	Si encontramos que una casilla contiene un # y tiene al menos otro # en su misma fila y columna, incrementamos el contador de semáforos.
	4.	Salida:
	•	Para cada caso de prueba, imprimimos el número de semáforos necesarios.

Ejemplo de entrada:

5 4
--#..
--#..
####'
:::##
7 3
..#....
#######
..#...#
7 4
..#....
#######
...#.#.
...#.#.
13 3
..#####...###
..#...#...#..
###...#####..
0 0

Ejemplo de salida:

1
3
2
4

Explicación de la salida:
	•	En el primer caso, solo hay una intersección donde se encuentran dos calles (una horizontal y una vertical).
	•	En el segundo caso, hay tres intersecciones.
	•	En el tercer caso, hay dos intersecciones.
	•	En el cuarto caso, hay cuatro intersecciones.

Resumen:

Este enfoque resuelve el problema de contar las intersecciones en un plano de calles en forma de cuadrícula. Lo hace de manera eficiente, recorriendo cada casilla y comprobando si es parte de una intersección. El código también se asegura de manejar correctamente los límites y terminar cuando encuentra un caso de entrada 0 0.

==========



















